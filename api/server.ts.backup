import 'dotenv/config.js';
import express, { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import * as StellarSdk from '@stellar/stellar-sdk';
import { Redis } from '@upstash/redis';
import path from 'path';
import fs from 'fs';

// Import app from server.app.ts to get all the routes
import appInstance from './server.app';
import { startUnifiedServer } from './server.startup';
import { getMongoDb, getReputationScoresCollection } from '../server/db/mongoModels';
import * as reputationService from '../server/services/reputationService';
import protocol from '../server/config/reputaProtocol';
import { createRedisClient } from './server.redis';
import { setupAdminPortalAPIs } from './admin-portal-apis';

// ====================
// ENVIRONMENT VALIDATION
// ====================

function validateEnvironmentVariables() {
  const required = ['MONGODB_URI', 'MONGODB_DB_NAME'];
  const optional = ['KV_REST_API_URL', 'KV_REST_API_TOKEN'];
  const missing = [];
  const warnings = [];

  // Check required variables
  for (const envVar of required) {
    if (!process.env[envVar]) {
      missing.push(envVar);
    }
  }

  // Check optional variables
  for (const envVar of optional) {
    if (!process.env[envVar]) {
      warnings.push(envVar);
    }
  }

  // Log results
  if (missing.length > 0) {
    console.error('‚ùå CRITICAL: Missing required environment variables:');
    missing.forEach(envVar => console.error(`   - ${envVar}`));
    console.error('\nüö® Server cannot start without these variables!');
    process.exit(1);
  }

  if (warnings.length > 0) {
    console.warn('‚ö†Ô∏è  WARNING: Missing optional environment variables:');
    warnings.forEach(envVar => console.warn(`   - ${envVar}`));
    console.warn('‚ö†Ô∏è  Some features may not work properly.\n');
  }

  // Log successful validation
  console.log('‚úÖ Environment variables validation passed');
  console.log(`üìä MongoDB: ${process.env.MONGODB_URI ? 'CONNECTED' : 'NOT CONFIGURED'}`);
  console.log(`üóÑÔ∏è  Database: ${process.env.MONGODB_DB_NAME || 'undefined'}`);
  console.log(`üî¥ Redis: ${process.env.KV_REST_API_URL ? 'CONFIGURED' : 'NOT CONFIGURED'}`);
  console.log('');
}

// Run validation immediately
validateEnvironmentVariables();

// Create a new Express app for static serving
const app = express();

// Copy all routes from server.app.ts
app.use(appInstance);

// Setup admin portal APIs
setupAdminPortalAPIs(app);

// ====================
// ADMIN PORTAL ROUTES
// ====================

// Admin Portal main route
app.get('/reputa-admin-portal', (req: Request, res: Response) => {
  const filePath = path.resolve(process.cwd(), 'dist', 'index.html');
  console.log('Admin Portal requested, file path:', filePath);
  console.log('File exists:', fs.existsSync(filePath));
  
  if (fs.existsSync(filePath)) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      res.setHeader('Content-Type', 'text/html');
      res.send(content);
    } catch (err) {
      console.error('Error reading file:', err);
      res.status(500).send('Error reading file');
    }
  } else {
    res.status(404).send('File not found');
  }
});

// ====================
// API ROUTES
// ====================

// ADMIN PORTAL API - Protected endpoints
// ====================

// Initialize Redis asynchronously
let redis: any = null;
async function initializeRedis() {
  if (!redis) {
    redis = await createRedisClient();
  }
  return redis;
}

console.log('DATABASE_URL_CHECK:', process.env.MONGODB_URI ? 'CONNECTED TO ATLAS' : 'LOCAL DETECTED');
console.log('UPSTASH_CHECK:', (process.env.KV_REST_API_URL && process.env.KV_REST_API_TOKEN) ? 'UPSTASH CONFIGURED' : 'UPSTASH MISSING');

const PORT = Number(process.env.PORT) || 3001;

// ====================
// DATABASE UTILITIES
// ====================

async function listAvailableCollections() {
  try {
    const db = await safeGetMongoDb();
    const collections = await db.listCollections().toArray();
    console.log('üìã Available MongoDB Collections:');
    collections.forEach((col: any) => {
      console.log(`   - ${col.name}`);
    });
    console.log('');
    return collections.map((col: any) => col.name);
  } catch (error) {
    console.error('‚ùå Failed to list collections:', error);
    return [];
  }
}

// Run collection listing on startup
listAvailableCollections();

// Admin authentication
function verifyAdminPassword(req: Request): boolean {
  const adminPassword = process.env.ADMIN_PASSWORD || 'admin123';
  const headerPw = req.headers['x-admin-password'] as string;
  const queryPw = req.query.password as string;
  const bodyPw = req.body?.password;

  console.log('[ADMIN AUTH DEBUG]', {
    adminPassword: adminPassword ? '***' : 'not set',
    headerPw: headerPw ? '***' : 'not provided',
    queryPw: queryPw ? '***' : 'not provided',
    bodyPw: bodyPw ? '***' : 'not provided',
    method: req.method,
    url: req.url
  });

  const suppliedPassword = headerPw || queryPw || bodyPw;
  const isValid = suppliedPassword === adminPassword;

  console.log('[ADMIN AUTH RESULT]', {
    suppliedPassword,
    isValid,
    expectedPassword: adminPassword
  });

  return isValid;
}

// Graceful MongoDB connection wrapper
async function safeGetMongoDb() {
  try {
    return await getMongoDb();
  } catch (error) {
    console.error('MongoDB connection error:', error);
    throw error;
  }
}

// Graceful Redis operations wrapper
async function safeRedisOperation(operation: string, ...args: any[]) {
  const redisClient = await initializeRedis();
  if (!redisClient) {
    console.warn('‚ö†Ô∏è Redis not available, skipping operation:', operation);
    return null;
  }
  try {
    return await (redisClient as any)[operation](...args);
  } catch (error) {
    console.error(`Redis ${operation} error:`, error);
    return null;
  }
}

// Graceful database operations wrapper
async function safeDbOperation<T>(operation: () => Promise<T>, fallbackValue?: T): Promise<T | null> {
  try {
    return await operation();
  } catch (error) {
    console.error('Database operation error:', error);
    return fallbackValue || null;
  }
}

// Graceful count operation
async function safeCount(collection: any, query: any): Promise<number> {
  try {
    return await collection.countDocuments(query);
  } catch (error) {
    console.error('Count operation error:', error);
    return 0;
  }
}

// ====================
// MIDDLEWARE
// ====================

app.use(cors({ origin: '*', methods: '*', allowedHeaders: '*' }));
app.use(express.json());
app.use((req: Request, res: Response, next: NextFunction) => {
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
  res.setHeader('Access-Control-Allow-Headers', 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version, Authorization');
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  next();
});

app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.path}`);
  next();
});

// ====================
// API ROUTES
// ====================

// ADMIN PORTAL API - Protected endpoints
// ====================

app.get('/api/admin-portal/stats', async (req: Request, res: Response) => {
  console.log('[API] /api/admin-portal/stats request received');
  
  if (!verifyAdminPassword(req)) {
    console.log('[API] Authentication failed');
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const db = await safeGetMongoDb();
    
    // Get real stats from userv3 collection
    const totalUsers = await db.collection('userv3').countDocuments();
    const vipUsers = await db.collection('userv3').countDocuments({ vip: true });
    const recentActivity = await db.collection('userv3').countDocuments({
      lastUpdated: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) } // Last 24 hours
    });

    const stats = {
      totalUniqueUsers: totalUsers,
      totalVisits: totalUsers, // Each user counts as a visit for now
      totalVipUsers: vipUsers,
      recentActivity: recentActivity,
      lastUpdated: new Date().toISOString()
    };

    console.log(`[API] Stats returned: ${JSON.stringify(stats)}`);
    return res.json({
      success: true,
      stats
    });

  } catch (e: any) {
    console.error('[API] Stats API error:', e);
    return res.status(500).json({ 
      success: false,
      error: e.message,
      stats: {
        totalUniqueUsers: 0,
        totalVisits: 0,
        totalVipUsers: 0,
        recentActivity: 0,
        lastUpdated: new Date().toISOString()
      }
    });
  }
});

app.get('/api/admin-portal/users', async (req: Request, res: Response) => {
  console.log('[API] /api/admin-portal/users request received');
  
  if (!verifyAdminPassword(req)) {
    console.log('[API] Authentication failed');
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const db = await safeGetMongoDb();
    const searchQuery = req.query.search as string || '';
    console.log('[API] Search query:', searchQuery);

    // Build query
    const query: any = {};
    if (searchQuery) {
      query.$or = [
        { username: { $regex: searchQuery, $options: 'i' } },
        { 'metadata.raw.walletAddress': { $regex: searchQuery, $options: 'i' } },
        { email: { $regex: searchQuery, $options: 'i' } }
      ];
    }

    // Get users from userv3 collection
    const users = await db.collection('userv3')
      .find(query)
      .sort({ lastUpdated: -1 })
      .limit(100)
      .toArray();

    console.log(`[API] Found ${users.length} users`);

    // Transform to expected format
    const transformedUsers = users.map((user: any) => {
      return {
        _id: user.uid || user._id?.toString(),
        username: user.username || user.displayName || `user_${user.uid?.substring(0, 8)}`,
        wallets: user.walletAddress ? [user.walletAddress] : [],
        visitCount: 1,
        isVip: user.vip === true,
        paymentDetails: null,
        reputaScore: user.metadata?.raw?.totalReputationScore || 0,
        firstSeen: user.metadata?.raw?.createdAt || user.createdAt || new Date(),
        lastSeen: user.lastUpdated || new Date(),
        email: user.email || user.metadata?.raw?.email,
        referralCount: 0,
        protocolVersion: '3.0'
      };
    });

    return res.json({
      success: true,
      users: transformedUsers
    });

  } catch (e: any) {
    console.error('[API] Users API error:', e);
    return res.status(500).json({ 
      success: false,
      error: e.message,
      users: []
    });
  }
});

// ====================
// ADMIN PORTAL API - Protected endpoints
// ====================

app.get('/api/admin-portal/stats', async (req: Request, res: Response) => {
  // Prevent browser caching for real-time data
  res.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
  res.set('Pragma', 'no-cache');
  res.set('Expires', '0');

  if (!verifyAdminPassword(req)) return res.status(401).json({ error: 'Unauthorized' });

  try {
    const db = await safeGetMongoDb();
    const trafficCol = db.collection('TrafficUsers');
    
    // Get total users
    const totalUsers = await safeCount(trafficCol, {});
    
    // Get VIP users
    const vipUsers = await safeCount(trafficCol, { isVip: true });
    
    // Get recent activity (last 24 hours)
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
    const recentActivity = await safeCount(trafficCol, { 
      lastSeen: { $gte: oneDayAgo.toISOString() }
    });

    return res.json({
      success: true,
      stats: {
        totalUsers,
        vipUsers,
        recentActivity,
        lastUpdated: new Date().toISOString()
      }
    });

  } catch (e: any) {
    console.error('[API] Stats API error:', e);
    return res.status(500).json({ 
      success: false,
      error: e.message,
      stats: {
        totalUsers: 0,
        vipUsers: 0,
        recentActivity: 0,
        lastUpdated: new Date().toISOString()
      }
    });
  }
});

app.get('/api/admin-portal/paid-users', async (req: Request, res: Response) => {
  console.log('[API] /api/admin-portal/paid-users request received');
  
  if (!verifyAdminPassword(req)) {
    console.log('[API] Authentication failed');
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const db = await safeGetMongoDb();
    
    // Get VIP users from userv3 collection
    const paidUsers = await db.collection('userv3')
      .find({ vip: true })
      .sort({ lastUpdated: -1 })
      .limit(100)
      .toArray();

    console.log(`[API] Found ${paidUsers.length} paid users`);

    // Transform to expected format
    const transformedPaidUsers = paidUsers.map((user: any) => {
      return {
        _id: user.uid || user._id?.toString(),
        username: user.username || user.displayName || `user_${user.uid?.substring(0, 8)}`,
        wallets: user.walletAddress ? [user.walletAddress] : [],
        visitCount: 1,
        isVip: true,
        paymentDetails: null,
        reputaScore: user.metadata?.raw?.totalReputationScore || 0,
        firstSeen: user.metadata?.raw?.createdAt || user.createdAt || new Date(),
        lastSeen: user.lastUpdated || new Date(),
        email: user.email || user.metadata?.raw?.email,
        referralCount: 0,
        protocolVersion: '3.0'
      };
    });

    return res.json({
      success: true,
      paidUsers: transformedPaidUsers
    });

  } catch (e: any) {
    console.error('[API] Paid users API error:', e);
    return res.status(500).json({ 
      success: false,
      error: e.message,
      paidUsers: []
    });
  }
});

app.get('/api/admin-portal/consolidated', async (req: Request, res: Response) => {
  console.log('[API] /api/admin-portal/consolidated request received');
  
  if (!verifyAdminPassword(req)) {
    console.log('[API] Authentication failed');
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const db = await safeGetMongoDb();
    const searchQuery = req.query.search as string || '';

    // Build unified aggregation pipeline
    const pipeline: any[] = [];
    
    // Add search filter if provided
    if (searchQuery) {
      const matchStage: any = {
        $match: {
          $or: [
            { username: { $regex: searchQuery, $options: 'i' } },
            { primaryWallet: { $regex: searchQuery, $options: 'i' } },
            { primaryEmail: { $regex: searchQuery, $options: 'i' } }
          ]
        }
      };
      pipeline.push(matchStage);
    }

    const sortStage: any = { $sort: { lastActiveAt: -1 } };
    pipeline.push(sortStage);

    // Execute aggregation
    const consolidatedUsers = await db.collection('TrafficUsers')
      .aggregate(pipeline)
      .limit(200)
      .toArray();

    // Extract usernames for feedback lookup
    const usernames = consolidatedUsers.map((u: any) => u.username).filter(Boolean);

    // Get reputation scores
    type ReputationScore = { pioneerId: string; totalReputationScore?: number };
    let reputationScores: ReputationScore[] = [];
    try {
      // Extract all pioneer IDs safely
      const allPioneerIds = consolidatedUsers
        .flatMap((u: any) => {
          const ids = u.allPioneerIds;
          return Array.isArray(ids) ? ids : (u.pioneerId ? [u.pioneerId] : []);
        })
        .filter(Boolean);
      
      const scores = await db.collection<ReputationScore>('ReputationScores')
        .find({ pioneerId: { $in: allPioneerIds } })
        .toArray();
      reputationScores = scores as ReputationScore[];
    } catch (e) {
      console.warn('ReputationScores collection not found:', e);
    }

    // Get feedback data
    type FeedbackData = { username: string; [key: string]: any };
    let feedbackData: FeedbackData[] = [];
    try {
      const feedback = await db.collection<FeedbackData>('all_feedbacks')
        .find({ username: { $in: usernames } })
        .toArray();
      feedbackData = feedback as FeedbackData[];
    } catch (e) {
      console.warn('all_feedbacks collection not found:', e);
    }

    // Create lookup maps
    const reputationMap = new Map(
      reputationScores.map(r => [r.pioneerId, r.totalReputationScore || 0])
    );
    const feedbackMap = new Map(
      feedbackData.map(f => [f.username, f])
    );

    // Transform data
    const transformedUsers = consolidatedUsers.map((user: any) => {
      // Ensure allPioneerIds is an array
      const allPioneerIds = Array.isArray(user.allPioneerIds) ? user.allPioneerIds : (user.pioneerId ? [user.pioneerId] : []);
      
      const totalReputation = allPioneerIds.reduce((sum: number, pid: string) => {
        return sum + (reputationMap.get(pid) || 0);
      }, 0);

      return {
        uid: user.pioneerId,
        username: user.username,
        primaryWallet: user.primaryWallet,
        primaryEmail: user.primaryEmail,
        createdAt: user.createdAt,
        lastActiveAt: user.lastActiveAt,
        isConsolidated: true,
        recordCount: allPioneerIds.length || 1,
        allPioneerIds: allPioneerIds,
        reputaScore: totalReputation,
        hasFeedback: feedbackMap.has(user.username),
        feedback: feedbackMap.get(user.username) || null,
        sources: user.sources || ['TrafficUsers']
      };
    });

    // Sort by last active date
    transformedUsers.sort((a: any, b: any) => {
      return new Date(b.lastActiveAt).getTime() - new Date(a.lastActiveAt).getTime();
    });

    console.log(`[API] Returning ${transformedUsers.length} consolidated users`);
    return res.json({
      success: true,
      users: transformedUsers,
      count: transformedUsers.length,
      meta: {
        totalRecords: transformedUsers.reduce((sum: number, u: any) => sum + u.recordCount, 0),
        consolidatedUsers: transformedUsers.filter((u: any) => u.isConsolidated).length,
        usersWithScores: transformedUsers.filter((u: any) => u.reputaScore > 0).length,
        usersWithFeedback: transformedUsers.filter((u: any) => u.hasFeedback).length,
        searchQuery: searchQuery || null
      }
    });

  } catch (e: any) {
    console.error('[API] Consolidated API error:', e);
    return res.status(500).json({ error: e.message });
  }
});

// ====================
// MAIN ADMIN DATA ENDPOINT
// ====================

app.get('/api/admin/consolidated-data', async (req: Request, res: Response) => {
  console.log('üî• [CONSOLIDATED-DATA] Endpoint HIT - Request received');
  console.log('üî• [CONSOLIDATED-DATA] Method:', req.method);
  console.log('üî• [CONSOLIDATED-DATA] URL:', req.url);
  console.log('üî• [CONSOLIDATED-DATA] Headers:', req.headers);
  
  if (!verifyAdminPassword(req)) {
    console.log('üî• [CONSOLIDATED-DATA] Authentication failed');
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const db = await safeGetMongoDb();
    const searchQuery = req.query.search as string || '';
    console.log('[API] Search query:', searchQuery);

    // Initialize Redis with fallback
    let redisClient;
    try {
      redisClient = await initializeRedis();
      console.log('[API] Redis initialized successfully');
    } catch (redisError) {
      console.warn('[API] Redis initialization failed, using MongoDB only:', redisError);
      redisClient = null;
    }

    // Try to get data from Redis first
    let cachedData = null;
    const cacheKey = `admin_consolidated_data_${searchQuery || 'all'}`;
    
    // Force fresh data fetch by skipping cache for now
    console.log('[API] Skipping cache to force fresh data fetch');
    
    if (redisClient) {
      try {
        // Clear the cache to force fresh data
        await redisClient.del(cacheKey);
        console.log('[API] Cache cleared');
      } catch (clearError) {
        console.warn('[API] Failed to clear cache:', clearError);
      }
    }

    // Fetch from MongoDB if no cached data
    console.log('[API] Fetching fresh data from MongoDB');
    
    // Debug: Check what collections actually have data
    console.log('[API] Checking collection contents...');
    try {
      const userv3Count = await db.collection('userv3').countDocuments();
      const finalUsersCount = await db.collection('final_users_v3').countDocuments();
      const rawdatasCount = await db.collection('rawdatas').countDocuments();
      console.log(`[API] Collection counts - userv3: ${userv3Count}, final_users_v3: ${finalUsersCount}, rawdatas: ${rawdatasCount}`);
      
      // Get a sample document to understand structure
      if (userv3Count > 0) {
        const sampleUser = await db.collection('userv3').findOne();
        console.log('[API] Sample userv3 document:', sampleUser);
      }
    } catch (debugError) {
      console.warn('[API] Debug check failed:', debugError);
    }
    
    // Build aggregation pipeline
    const pipeline: any[] = [];
    
    // Add search filter if provided
    if (searchQuery) {
      const matchStage: any = {
        $match: {
          $or: [
            { username: { $regex: searchQuery, $options: 'i' } },
            { primaryWallet: { $regex: searchQuery, $options: 'i' } },
            { primaryEmail: { $regex: searchQuery, $options: 'i' } }
          ]
        }
      };
      pipeline.push(matchStage);
    }

    const sortStage: any = { $sort: { lastActiveAt: -1 } };
    pipeline.push(sortStage);

    // Execute aggregation on userv3 collection (most likely to have data)
    let consolidatedUsers = await db.collection('userv3')
      .aggregate(pipeline)
      .limit(200)
      .toArray();

    console.log(`[API] Found ${consolidatedUsers.length} users in MongoDB`);

    // If no users found, try other collections or create sample data
    if (consolidatedUsers.length === 0) {
      console.log('[API] No users found in userv3, trying other collections...');
      
      // Try rawdatas collection
      consolidatedUsers = await db.collection('rawdatas')
        .aggregate(pipeline)
        .limit(200)
        .toArray();
      console.log(`[API] Found ${consolidatedUsers.length} users in rawdatas`);
      
      // If still no data, create sample data for testing
      if (consolidatedUsers.length === 0) {
        console.log('[API] No data found in any collection, creating sample data...');
        const now = new Date();
        consolidatedUsers = [
          {
            pioneerId: 'sample_user_1',
            username: 'testuser1',
            primaryWallet: 'GABC123DEF456',
            primaryEmail: 'test1@example.com',
            createdAt: now,
            lastActiveAt: now,
            visitCount: 5,
            isVip: false,
            allPioneerIds: ['sample_user_1']
          },
          {
            pioneerId: 'sample_user_2',
            username: 'testuser2',
            primaryWallet: 'GXYZ789ABC123',
            primaryEmail: 'test2@example.com',
            createdAt: now,
            lastActiveAt: now,
            visitCount: 3,
            isVip: true,
            allPioneerIds: ['sample_user_2']
          }
        ];
        console.log('[API] Created sample data for testing');
      }
    }

    // Get additional data
    const usernames = consolidatedUsers.map((u: any) => u.username).filter(Boolean);
    
    // Get reputation scores
    let reputationScores: any[] = [];
    try {
      const allPioneerIds = consolidatedUsers
        .flatMap((u: any) => {
          const ids = u.allPioneerIds;
          return Array.isArray(ids) ? ids : (u.pioneerId ? [u.pioneerId] : []);
        })
        .filter(Boolean);
      
      if (allPioneerIds.length > 0) {
        const scores = await db.collection('ReputationScores')
          .find({ pioneerId: { $in: allPioneerIds } })
          .toArray();
        reputationScores = scores;
      }
    } catch (e) {
      console.warn('[API] ReputationScores collection error:', e);
    }

    // Get feedback data
    let feedbackData: any[] = [];
    try {
      if (usernames.length > 0) {
        const feedback = await db.collection('all_feedbacks')
          .find({ username: { $in: usernames } })
          .toArray();
        feedbackData = feedback;
      }
    } catch (e) {
      console.warn('[API] Feedback collection error:', e);
    }

    // Create lookup maps
    const reputationMap = new Map(
      reputationScores.map(r => [r.pioneerId, r.totalReputationScore || 0])
    );
    const feedbackMap = new Map(
      feedbackData.map(f => [f.username, f])
    );

    // Transform data to match expected structure
    const transformedUsers = consolidatedUsers.map((user: any) => {
      // Handle userv3 collection structure
      const uid = user.uid || user._id?.toString();
      const username = user.username || user.displayName || `user_${uid?.substring(0, 8)}`;
      const primaryWallet = user.walletAddress || user.metadata?.raw?.walletAddress || '';
      const primaryEmail = user.email || user.metadata?.raw?.email || '';
      const createdAt = user.createdAt || user.metadata?.raw?.createdAt || new Date();
      const lastActiveAt = user.lastUpdated || user.metadata?.raw?.lastUpdated || new Date();
      const visitCount = user.visitCount || 0;
      const isVip = user.vip === true || user.isVip === true;
      
      // Extract pioneer IDs
      let allPioneerIds = [uid];
      if (user.allPioneerIds && Array.isArray(user.allPioneerIds)) {
        allPioneerIds = user.allPioneerIds;
      }
      
      const totalReputation = allPioneerIds.reduce((sum: number, pid: string) => {
        return sum + (reputationMap.get(pid) || 0);
      }, 0);

      return {
        // TrafficUser base fields
        _id: uid,
        username,
        wallets: primaryWallet ? [primaryWallet] : [],
        visitCount,
        isVip,
        paymentDetails: null,
        reputaScore: totalReputation,
        firstSeen: createdAt.toISOString(),
        lastSeen: lastActiveAt.toISOString(),
        email: primaryEmail,
        referralCount: 0,
        protocolVersion: '3.0',
        
        // ConsolidatedUser extended fields
        primaryWallet,
        allWallets: primaryWallet ? [primaryWallet] : [],
        primaryPioneerId: uid,
        allPioneerIds,
        primaryEmail,
        sources: ['userv3'],
        maxReferralCount: 0,
        protocolVersions: ['3.0'],
        recordCount: allPioneerIds.length,
        isConsolidated: true,
        feedbackCount: feedbackMap.has(username) ? 1 : 0,
        hasFeedback: feedbackMap.has(username),
        checkinCount: 0,
        lastCheckin: undefined,
        activityScore: totalReputation,
        dataCompleteness: {
          hasWallet: !!primaryWallet,
          hasPioneerId: !!uid,
          hasEmail: !!primaryEmail,
          hasPayment: false,
          hasReputation: totalReputation > 0
        }
      };
    });

    // Sort by last active date
    transformedUsers.sort((a: any, b: any) => {
      return new Date(b.lastActiveAt).getTime() - new Date(a.lastActiveAt).getTime();
    });

    // Calculate statistics
    const uniqueUsers = transformedUsers.length;
    const totalVisits = transformedUsers.reduce((sum, user) => {
      // Try multiple fields for visit count
      const visitCount = user.visitCount || 
                        (user as any).metadata?.raw?.visitCount || 
                        (user as any).totalCheckInDays || 
                        (user as any).reputation?.totalCheckInDays || 
                        0;
      return sum + visitCount;
    }, 0);
    const vipUsers = transformedUsers.filter(user => user.isVip).length;
    const usersWithScores = transformedUsers.filter(user => user.reputaScore > 0).length;
    const usersWithFeedback = transformedUsers.filter(user => user.hasFeedback).length;

    // Create final response structure
    const responseData = {
      success: true,
      uniqueUsers,
      totalVisits,
      vipUsers,
      usersWithScores,
      usersWithFeedback,
      lastUpdated: new Date().toISOString(),
      searchQuery: searchQuery || null,
      users: transformedUsers,
      meta: {
        totalRecords: transformedUsers.reduce((sum: number, u: any) => sum + u.recordCount, 0),
        consolidatedUsers: transformedUsers.filter((u: any) => u.isConsolidated).length,
        averageReputation: uniqueUsers > 0 ? Math.round(transformedUsers.reduce((sum, u) => sum + u.reputaScore, 0) / uniqueUsers) : 0
      }
    };

    // Cache the response in Redis
    if (redisClient) {
      try {
        await redisClient.set(cacheKey, JSON.stringify(responseData), { ex: 300 }); // Cache for 5 minutes
        console.log('[API] Data cached in Redis');
      } catch (cacheError) {
        console.warn('[API] Failed to cache data:', cacheError);
      }
    }

    console.log(`[API] Returning ${uniqueUsers} unique users, ${totalVisits} total visits`);
    return res.json(responseData);

  } catch (e: any) {
    console.error('[API] Consolidated data error:', e);
    console.error('[API] Error stack:', e.stack);
    return res.status(500).json({ 
      success: false,
      error: e.message,
      uniqueUsers: 0,
      totalVisits: 0,
});

app.post('/api/admin-portal/mark-vip', async (req: Request, res: Response) => {
if (!verifyAdminPassword(req)) return res.status(401).json({ error: 'Unauthorized' });
  if (!verifyAdminPassword(req)) return res.status(401).json({ error: 'Unauthorized' });

  try {
    const { username, paymentId, txid, amount } = req.body;
    if (!username) return res.status(400).json({ error: 'username required' });

    const db = await safeGetMongoDb();
    const trafficCol = db.collection('TrafficUsers');
    
    await trafficCol.updateOne(
      { username },
      {
        $set: {
          isVip: true,
          paymentDetails: {
            paymentId: paymentId || 'manual',
            txid: txid || 'manual',
            amount: amount || 0,
            paidAt: new Date(),
          },
          updatedAt: new Date(),
        },
      },
      { upsert: true }
    );

    // Also update Upstash for speed
    await safeRedisOperation('set', `vip_status:${username}`, 'active', { ex: 365 * 24 * 60 * 60 });

    return res.json({ success: true, message: `${username} marked as VIP` });
  } catch (e: any) {
    return res.status(500).json({ error: e.message });
  }
});

// ====================
// AUTH
// ====================

app.post('/api/auth', async (req: Request, res: Response) => {
  try {
    const { accessToken, user } = req.body as { accessToken: string; user?: { uid: string; username: string } };

    if (!accessToken) {
      return res.status(400).json({ error: 'Access token is required' });
    }

    // Here you would validate the access token with Pi Network
    // For now, we'll just return success
    return res.json({
      success: true,
      message: 'Authentication successful',
      user: user || { uid: 'demo-uid', username: 'demo-user' }
    });
  } catch (error: any) {
    console.error('Auth error:', error);
    return res.status(500).json({ error: error.message });
  }
});

// ====================
// USER API
// ====================

app.get('/api/user', async (req: Request, res: Response) => {
  const { action, uid } = req.query;

  switch (action) {
    case 'check-vip':
      return handleCheckVip(uid as string, res);
    case 'get-reputation':
      return handleGetReputation(uid as string, res);
    case 'get-wallet-state':
      return handleGetWalletState(uid as string, res);
    default:
      return res.status(400).json({ error: 'Invalid action' });
  }
});

app.post('/api/user', async (req: Request, res: Response) => {
  const body = typeof req.body === 'string' ? JSON.parse(req.body) : req.body;
  const { type, action } = body;

  switch (type) {
    case 'pioneer':
      if (action === 'save') return handleSavePioneer(body, res);
      break;
    case 'feedback':
      if (action === 'save') return handleSaveFeedback(body, res);
      break;
    case 'reputation':
      if (action === 'save') return handleSaveReputation(body, res);
      if (action === 'merge-checkin') return handleMergeCheckInPoints(body, res);
      break;
    case 'wallet':
      if (action === 'save') return handleSaveWalletState(body, res);
      break;
  }

  return res.status(400).json({ error: 'Invalid request' });
});

app.get('/api/check-vip', async (req: Request, res: Response) => handleCheckVip(req.query.uid as string, res));
app.post('/api/save-pioneer', async (req: Request, res: Response) => handleSavePioneer(req.body, res));
app.post('/api/save-feedback', async (req: Request, res: Response) => handleSaveFeedback(req.body, res));

// ====================
// ATOMIC REPUTATION ENGINE API ENDPOINTS
// ====================

app.post('/api/atomic/deep-scan', async (req: Request, res: Response) => {
  try {
    const { walletAddress, username } = req.body;
    
    if (!walletAddress || !username) {
      return res.status(400).json({ error: 'walletAddress and username are required' });
    }

    const result = await performInitialDeepScan(walletAddress, username);
    
    return res.json({
      success: result.success,
      data: result.genesisBoostData,
      scanResult: result.scanResult
    });
  } catch (error: any) {
    console.error('Deep scan error:', error);
    return res.status(500).json({ error: error.message });
  }
});

app.post('/api/atomic/sync', async (req: Request, res: Response) => {
  try {
    const { username } = req.body;
    
    if (!username) {
      return res.status(400).json({ error: 'username is required' });
    }

    const result = await performIncrementalSync(username);
    
    return res.json({
      success: result.success,
      newRewards: result.newRewards,
      scanResult: result.scanResult
    });
  } catch (error: any) {
    console.error('Incremental sync error:', error);
    return res.status(500).json({ error: error.message });
  }
});

app.get('/api/atomic/profile', async (req: Request, res: Response) => {
  try {
    const { username } = req.query;
    
    if (!username) {
      return res.status(400).json({ error: 'username is required' });
    }

    const db = await safeGetMongoDb();
    const profile = await db.collection('AtomicProfiles').findOne({ username });
    
    if (!profile) {
      return res.status(404).json({ error: 'Profile not found' });
    }

    return res.json({ success: true, profile });
  } catch (error: any) {
    console.error('Get profile error:', error);
    return res.status(500).json({ error: error.message });
  }
});

app.post('/api/atomic/claim-rewards', async (req: Request, res: Response) => {
  try {
    const { username } = req.body;
    
    if (!username) {
      return res.status(400).json({ error: 'username is required' });
    }

    // Process reward claims
    const db = await safeGetMongoDb();
    const result = await db.collection('PendingRewards').updateMany(
      { username, claimed: false },
      { $set: { claimed: true, claimedAt: new Date() } }
    );

    return res.json({
      success: true,
      claimed: result.modifiedCount
    });
  } catch (error: any) {
    console.error('Claim rewards error:', error);
    return res.status(500).json({ error: error.message });
  }
});

app.get('/api/atomic/leaderboard', async (req: Request, res: Response) => {
  try {
    const limit = Math.min(parseInt(req.query.limit as string) || 100, 100);
    const offset = parseInt(req.query.offset as string) || 0;
    
    const db = await safeGetMongoDb();
    const leaderboard = await db.collection('AtomicProfiles')
      .find({})
      .sort({ atomicTrustScore: -1 })
      .skip(offset)
      .limit(limit)
      .toArray();

    return res.json({ success: true, leaderboard });
  } catch (error: any) {
    console.error('Leaderboard error:', error);
    return res.status(500).json({ error: error.message });
  }
});

// ====================
// HELPER FUNCTIONS
// ====================

type AtomicTrustLevel = 'Newcomer' | 'Novice' | 'Explorer' | 'Contributor' | 'Verified' | 'Trusted' | 'Ambassador' | 'Elite' | 'Sentinel' | 'Oracle' | 'Atomic Legend';

function computeTrustLevel(score: number): AtomicTrustLevel {
  if (score >= 950_001) return 'Atomic Legend';
  if (score >= 850_001) return 'Oracle';
  if (score >= 750_001) return 'Sentinel';
  if (score >= 650_001) return 'Elite';
  if (score >= 550_001) return 'Ambassador';
  if (score >= 450_001) return 'Trusted';
  if (score >= 350_001) return 'Verified';
  if (score >= 250_001) return 'Contributor';
  if (score >= 150_001) return 'Explorer';
  if (score >= 50_001) return 'Novice';
  return 'Newcomer';
}

async function handleCheckVip(uid: string | undefined, res: Response) {
  if (!uid) {
    return res.status(400).json({ error: 'Missing uid' });
  }

  try {
    const db = await safeGetMongoDb();
    const trafficCol = db.collection('TrafficUsers');
    const user = await trafficCol.findOne({ uid });
    
    const isVip = user?.isVip || false;
    const count = await safeCount(trafficCol, { isVip: true });

    return res.status(200).json({ isVip, count });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
}

async function handleSavePioneer(body: any, res: Response) {
  const { username, wallet, timestamp } = body;

  if (!username) {
    return res.status(400).json({ error: 'Missing username' });
  }

  try {
    const db = await safeGetMongoDb();
    const trafficCol = db.collection('TrafficUsers');
    
    await trafficCol.updateOne(
      { username },
      {
        $set: {
          wallet,
          timestamp: timestamp || new Date(),
          updatedAt: new Date()
        }
      },
      { upsert: true }
    );

    return res.status(200).json({ success: true, message: 'Pioneer saved' });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
}

async function handleSaveFeedback(body: any, res: Response) {
  const { username, text, timestamp } = body;

  if (!text) {
    return res.status(400).json({ error: 'Missing feedback text' });
  }

  try {
    const db = await safeGetMongoDb();
    const feedbackCol = db.collection('Feedback');
    
    await feedbackCol.insertOne({
      username,
      text,
      timestamp: timestamp || new Date()
    });

    return res.status(200).json({ success: true, message: 'Feedback saved' });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
}

async function handleGetReputation(uid: string | undefined, res: Response) {
  if (!uid) {
    return res.status(400).json({ error: 'Missing uid' });
  }

  try {
    const db = await safeGetMongoDb();
    const reputationCol = db.collection('Reputation');
    const data = await reputationCol.findOne({ uid });
    
    const parsed = data || {
      uid,
      totalReputationScore: 0,
      reputationLevel: 'Newcomer',
      blockchainScore: 0,
      checkInScore: 0,
      walletSnapshots: [],
      dailyCheckinHistory: [],
      scoreEvents: [],
      currentStreak: 0,
      longestStreak: 0,
      totalCheckInDays: 0,
      lastCheckInDate: null,
      lastScanTimestamp: null,
      lastUpdated: new Date(),
      createdAt: new Date()
    };

    return res.status(200).json({ success: true, data: parsed });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
}

async function handleSaveReputation(body: any, res: Response) {
  const {
    uid,
    username,
    totalReputationScore,
    reputationLevel,
    blockchainScore,
    checkInScore,
    walletSnapshots,
    dailyCheckinHistory,
    scoreEvents,
    currentStreak,
    longestStreak,
    totalCheckInDays,
    lastCheckInDate,
    lastScanTimestamp
  } = body;

  if (!uid) {
    return res.status(400).json({ error: 'Missing uid' });
  }

  try {
    const db = await safeGetMongoDb();
    const reputationCol = db.collection('Reputation');
    
    const reputationData = {
      uid,
      username,
      totalReputationScore: totalReputationScore || 0,
      reputationLevel: reputationLevel || 'Newcomer',
      blockchainScore: blockchainScore || 0,
      checkInScore: checkInScore || 0,
      walletSnapshots: walletSnapshots || [],
      dailyCheckinHistory: dailyCheckinHistory || [],
      scoreEvents: scoreEvents || [],
      currentStreak: currentStreak || 0,
      longestStreak: longestStreak || 0,
      totalCheckInDays: totalCheckInDays || 0,
      lastCheckInDate: lastCheckInDate || null,
      lastScanTimestamp: lastScanTimestamp || null,
      lastUpdated: new Date(),
      createdAt: new Date()
    };

    await reputationCol.updateOne(
      { uid },
      { $set: reputationData },
      { upsert: true }
    );

    return res.status(200).json({ success: true, data: reputationData });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
}

async function handleGetTopUsers(query: any, res: Response) {
  const limit = Math.min(parseInt(query.limit as string) || 100, 100);
  const offset = parseInt(query.offset as string) || 0;

  try {
    const db = await safeGetMongoDb();
    const reputationCol = db.collection('Reputation');
    
    const users = await reputationCol
      .find({})
      .sort({ totalReputationScore: -1 })
      .skip(offset)
      .limit(limit)
      .toArray();

    return res.status(200).json({ success: true, users });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
}

async function handleMergeCheckInPoints(body: any, res: Response) {
  const { uid, pointsToMerge } = body;

  if (!uid || typeof pointsToMerge !== 'number') {
    return res.status(400).json({ error: 'Invalid request' });
  }

  try {
    const db = await safeGetMongoDb();
    const reputationCol = db.collection('Reputation');
    
    const user = await reputationCol.findOne({ uid });
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    const newScore = user.totalReputationScore + pointsToMerge;
    const newLevel = computeTrustLevel(newScore);

    await reputationCol.updateOne(
      { uid },
      {
        $set: {
          totalReputationScore: newScore,
          reputationLevel: newLevel,
          lastUpdated: new Date()
        }
      }
    );

    const updated = await reputationCol.findOne({ uid });
    return res.status(200).json({ success: true, data: updated });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
}

async function handleGetWalletState(uid: string | undefined, res: Response) {
  if (!uid) {
    return res.status(400).json({ error: 'Missing uid' });
  }

  try {
    const db = await safeGetMongoDb();
    const walletCol = db.collection('WalletStates');
    const state = await walletCol.findOne({ uid });
    
    const parsed = state || {
      uid,
      walletAddress: null,
      balance: 0,
      transactionCount: 0,
      lastActivityDate: null,
      contactsCount: 0,
      stakingAmount: 0,
      accountAgeDays: 0,
      lastUpdated: new Date()
    };

    return res.status(200).json({ success: true, data: parsed });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
}

async function handleSaveWalletState(body: any, res: Response) {
  const { uid, walletState } = body;

  if (!uid || !walletState) {
    return res.status(400).json({ error: 'Invalid request' });
  }

  try {
    const db = await safeGetMongoDb();
    const walletCol = db.collection('WalletStates');
    
    await walletCol.updateOne(
      { uid },
      {
        $set: {
          ...walletState,
          uid,
          lastUpdated: new Date()
        }
      },
      { upsert: true }
    );

    return res.status(200).json({ success: true, message: 'Wallet state saved' });
  } catch (error: any) {
    return res.status(500).json({ error: error.message });
  }
}

// Blockchain scan functions
async function performInitialDeepScan(walletAddress: string, username: string): Promise<{
  success: boolean;
  genesisBoostData?: any;
  scanResult?: any;
}> {
  try {
    // Implementation for deep blockchain scanning
    const genesisBoostData = {
      walletAddress,
      username,
      accountAgeDays: 365,
      transactionCount: 1000,
      totalBalance: 1000000,
      genesisBoostScore: 50000
    };

    return {
      success: true,
      genesisBoostData,
      scanResult: { scanned: true, transactionsFound: 1000 }
    };
  } catch (error) {
    console.error('Deep scan error:', error);
    return { success: false };
  }
}

async function performIncrementalSync(username: string): Promise<{
  success: boolean;
  newRewards?: any[];
  scanResult?: any;
}> {
  try {
    // Implementation for incremental sync
    const newRewards = [
      { type: 'transaction_bonus', points: 10, txid: 'demo-tx-1' },
      { type: 'stake_bonus', points: 5, amount: 100 }
    ];

    return {
      success: true,
      newRewards,
      scanResult: { synced: true, newTransactions: 2 }
    };
  } catch (error) {
    console.error('Incremental sync error:', error);
    return { success: false };
  }
}

// ====================
// HEALTH CHECK
// ====================

app.get('/api/health-check', async (req: Request, res: Response) => {
  const status: any = {
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    mongodb: { status: 'disconnected', latency: null as number | null },
    redis: { status: 'disconnected', latency: null as number | null },
    memory: {
      used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
      total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),
      external: Math.round(process.memoryUsage().external / 1024 / 1024)
    }
  };

  // Check MongoDB
  try {
    const start = Date.now();
    await safeGetMongoDb();
    status.mongodb.latency = Date.now() - start;
    status.mongodb.status = 'connected';
  } catch (error) {
    status.mongodb.error = error instanceof Error ? error.message : 'Unknown error';
  }

  // Check Redis
  try {
    const redisClient = await initializeRedis();
    if (redisClient) {
      const start = Date.now();
      await safeRedisOperation('ping');
      status.redis.latency = Date.now() - start;
      status.redis.status = 'connected';
    }
  } catch (error) {
    status.redis.error = error instanceof Error ? error.message : 'Unknown error';
  }

  const overallStatus = status.mongodb.status === 'connected' && status.redis.status === 'connected' ? 'healthy' : 'degraded';
  
  return res.status(overallStatus === 'healthy' ? 200 : 503).json({
    ...status,
    overall: overallStatus
  });
});

// ====================
// STATIC FILE SERVING
// ====================

// Serve static files from dist directory
app.use('/assets', express.static(path.join(process.cwd(), 'dist', 'assets')));

// Admin Portal route
app.get('/reputa-admin-portal', (req: Request, res: Response) => {
  const filePath = path.resolve(process.cwd(), 'dist', 'index.html');
  console.log('Admin Portal requested, file path:', filePath);
  console.log('File exists:', fs.existsSync(filePath));
  
  if (fs.existsSync(filePath)) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      res.setHeader('Content-Type', 'text/html');
      res.send(content);
    } catch (err) {
      console.error('Error reading file:', err);
      res.status(500).send('Error reading file');
    }
  } else {
    res.status(404).send('File not found');
  }
});

// Catch-all handler for React Router - MUST BE AT THE END
app.use((req: Request, res: Response, next: NextFunction) => {
  if (req.path.startsWith('/api')) {
    return next();
  }
  res.sendFile(path.join(process.cwd(), 'dist', 'index.html'));
});

// ====================
// SERVER STARTUP
// ====================

const PORT_FINAL = Number(process.env.PORT) || 3001;

const entryArg = process.argv[1] ?? '';
const isDevStart = !process.env.VERCEL && (entryArg.includes('api/server') || entryArg.includes('api\\server') || entryArg.endsWith('/server.ts') || entryArg.endsWith('\\server.ts'));

if (isDevStart) {
  startUnifiedServer(app, PORT_FINAL);
}
